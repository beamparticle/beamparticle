%%%-------------------------------------------------------------------
%%% @doc
%%%
%%% @end
%%% %CopyrightBegin%
%%%
%%% Copyright Neeraj Sharma <neeraj.sharma@alumni.iitg.ernet.in> 2017.
%%% All Rights Reserved.
%%%
%%% Licensed under the Apache License, Version 2.0 (the "License");
%%% you may not use this file except in compliance with the License.
%%% You may obtain a copy of the License at
%%%
%%%     http://www.apache.org/licenses/LICENSE-2.0
%%%
%%% Unless required by applicable law or agreed to in writing, software
%%% distributed under the License is distributed on an "AS IS" BASIS,
%%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%%% See the License for the specific language governing permissions and
%%% limitations under the License.
%%%
%%% %CopyrightEnd%
%%%-------------------------------------------------------------------

-module(beamparticle_k_model).
-behaviour(beamparticle_callback).
-export([init/0, init/2, terminate/1, % CRUD
         validate/2, create/3, read/2, update/3, delete/2]).
-export([create/4, update/4]).
-export_type([beamparticle_k/0]).

-include("beamparticle_constants.hrl").

-type beamparticle_k() :: binary().
-type state() :: term().

%%%===================================================================
%%% API
%%%===================================================================

%%%===================================================================
%%% Callbacks
%%%===================================================================

%% @doc Initialize the state that the handler will carry for
%% a specific request throughout its progression. The state
%% is then passed on to each subsequent call to this model.
-spec init() -> state().
init() ->
    nostate.

init(_, _) ->
    init().

%% @doc At the end of a request, the state is passed back in
%% to allow for clean up.
-spec terminate(state()) -> term().
terminate(_State) ->
    ok.

%% @doc Return, via a boolean value, whether the user-submitted
%% data structure is considered to be valid by this model's standard.
-spec validate(beamparticle_k() | term(), state()) -> {boolean(), state()}.
validate(V, State) ->
    {is_binary(V) andalso byte_size(V) > 0, State}.

%% @doc Create a new entry. If the id is `undefined', the user
%% has not submitted an id under which to store the resource:
%% the id needs to be generated by the model, and (if successful),
%% returned via `{true, GeneratedId}'.
%% Otherwise, a given id will be passed, and a simple `true' or
%% `false' value may be returned to confirm the results.
%%
%% The created resource is validated before this function is called.
-spec create(beamparticle_callback:id() | undefined, beamparticle_k(), state()) ->
        {false | true | {true, beamparticle_callback:id()}, state()}.
create(undefined, V, State) ->
    NewId = create_id(),
    % directly read and write binary(), but then this will break the
    % generic abstraction of json resource.
    { {?STORE_MODULE:create(?MODULE, NewId, V, State), NewId}, State};
create(Id, V, State) ->
    {?STORE_MODULE:create(?MODULE, Id, V, State), State}.

%% @doc Create a new entry along with an expiry of some seconds.
-spec create(beamparticle_callback:id() | undefined, beamparticle_k(), [{binary(), binary()}], state()) ->
    {false | true | {true, beamparticle_callback:id()}, state()}.
create(Id, V, QsProplist, State) ->
    {Resp, State2} = create(Id, V, State),
    case proplists:get_value(<<"e">>, QsProplist, undefined) of
        ExpiryBin when is_binary(ExpiryBin) ->
            ExpirySeconds = binary_to_integer(ExpiryBin),
            lager:debug("create(~p, ~p, ~p, ~p) -> ~p", [Id, V, ExpirySeconds, State, Resp]),
            Id3 = case Resp of
                      {true, Id2} -> Id2;
                      _ -> Id
                  end,
            State4 = case Resp of
                false -> State2;
                _ ->
                    {Mega, Sec, _Micro} = os:timestamp(),
                    NowInSeconds = Mega * 1000 + Sec + ExpirySeconds,
                    ExpKey = <<?KSTORE_EXPIRY_TYPE, Id3/binary>>,
                    TimeVal = <<NowInSeconds:64>>,
                    %% dont care about whether expiry gets stored
                    ?STORE_MODULE:create(?MODULE, ExpKey, TimeVal, State2),
                    State2
            end,
            {Resp, State4};
        _ ->
            {Resp, State2}
    end.

%% @doc Read a given entry from the store based on its Id.
-spec read(beamparticle_callback:id(), state()) ->
        { {ok, beamparticle_k()} | {error, not_found}, state()}.
read(Id, State) ->
    %% Make reads much faster by hitting the cache in model
    %% itself, rather than going with the datastore worker pool.
    %% TODO: there is a double penalty in leveldbstore
    Resp = case beamparticle_cache_util:get(Id) of
               {ok, Data} ->
                   {ok, Data};
               _ ->
                   ?STORE_MODULE:read(?MODULE, Id, State)
           end,
    {Resp, State}.

%% @doc Update an existing resource.
%%
%% The modified resource is validated before this function is called.
-spec update(beamparticle_callback:id(), beamparticle_k(), state()) -> {boolean(), state()}.
update(Id, V, State) ->
    %% remove expiry key when update without an expiry
    ExpKey = <<?KSTORE_EXPIRY_TYPE, Id/binary>>,
    ?STORE_MODULE:delete(?MODULE, ExpKey, State),
    {?STORE_MODULE:update(?MODULE, Id, V, State), State}.

%% @doc Update an existing resource with some expiry seconds.
-spec update(beamparticle_callback:id(), beamparticle_k(), integer(), state()) -> {boolean(), state()}.
update(Id, V, QsProplist, State) ->
    case proplists:get_value(<<"e">>, QsProplist, undefined) of
        ExpiryBin when is_binary(ExpiryBin) ->
            ExpirySeconds = binary_to_integer(ExpiryBin),
            {Mega, Sec, _Micro} = os:timestamp(),
            NowInSeconds = Mega * 1000 + Sec + ExpirySeconds,
            ExpKey = <<?KSTORE_EXPIRY_TYPE, Id/binary>>,

            VExpKey = <<NowInSeconds:64>>,
            %% dont care about whether expiry gets updated
            ?STORE_MODULE:update(?MODULE, ExpKey, VExpKey, State),
            {?STORE_MODULE:update(?MODULE, Id, V, State), State};
        undefined ->
            update(Id, V, State)
    end.

%% @doc Delete an existing resource.
-spec delete(beamparticle_callback:id(), state()) -> {boolean(), state()}.
delete(Id, State) ->
    %% remove expiry key (if present) as well
    ExpKey = <<?KSTORE_EXPIRY_TYPE, Id/binary>>,
    ?STORE_MODULE:delete(?MODULE, ExpKey, State),
    {?STORE_MODULE:delete(?MODULE, Id, State), State}.

%%%===================================================================
%%% Internal
%%%===================================================================

-spec create_id() -> beamparticle_callback:id().
create_id() ->
    list_to_binary(uuid:uuid_to_string(uuid:get_v4())).
